import { toast } from "react-toastify";
import DeliveriesInfo from "../interfaces/types/DeliveriesInfo";
import { DeliveryItem, DeliveryList } from "../interfaces/DeliveryList";
import { Franchise } from "../interfaces/Franchise";
import makeRequest from "../services/makeRequest";
import calculateDistanceBetweenTwoPoints from "./calculateDistanceBetweenTwoPoints";
import createVROOMExpressParamsObject from "./createVROOMExpressParamsObject";
import formatRoutedDeliveryList from "./formatRoutedDeliveryList";
import { getLocalStorageItem } from "./manageLocalStorage";

/* Function to calculate the best routing for the delivery list,
  format it, and return and object with the routed delivery list and
  the route details */
const getRoutedDeliveryList = async (
  franchise: Franchise,
  deliveryList: DeliveryList,
  isTheFirstFetch: boolean,
  listId?: number
) => {
  try {
    const maxDistanceAllowed = getLocalStorageItem("maxDistanceFromFranchise")
      ? getLocalStorageItem("maxDistanceFromFranchise")
      : 200;

    // Some HAWBs may have no lat and lng or its distance from
    // the franchise location its too big, so in those cases,
    // it is automatically marked as removed from the list,
    // but only on the first time the list is fetched
    if (isTheFirstFetch) {
      deliveryList.forEach((delivery) => {
        const distanceFromFranchise = calculateDistanceBetweenTwoPoints(
          {
            lat: Number(franchise.lat),
            lng: Number(franchise.lng),
          },
          { lat: Number(delivery.lat), lng: Number(delivery.lng) },
          "K"
        );

        if (
          (delivery.lat === "0" && delivery.lng === "0") ||
          distanceFromFranchise > maxDistanceAllowed
        ) {
          delivery.isRemoved = true;
          toast.warning(
            "Algumas HAWBs foram removidas automaticamente, verifique no final da lista",
            {
              toastId: "autoRemovedHAWBs",
            }
          );
          return;
        }

        delivery.isRemoved = false;
      });
    }

    const notRemovedDeliveryList = deliveryList.filter(
      (delivery) => !delivery.isRemoved
    );
    const removedDeliveryList = deliveryList.filter(
      (delivery) => delivery.isRemoved
    );

    /* Second request to sort the deliveries by the best routing possible */
    const routedDeliveryList = await makeRequest({
      url: `https://rotasexpress.flashcourier.com.br`,
      method: "post",
      options: {
        params: createVROOMExpressParamsObject(
          franchise,
          notRemovedDeliveryList.length > 0
            ? notRemovedDeliveryList
            : removedDeliveryList,
          listId
        ),
      },
    });

    if (routedDeliveryList.hasOwnProperty("error")) {
      throw new Error();
    }

    /* Array with the id that matches the job id from the routed
        delivery list generated by the VROOM Express API so its
        possible to assign the address and hawb to the job */
    const deliveriesInfo = [
      ...(notRemovedDeliveryList.length > 0
        ? notRemovedDeliveryList
        : removedDeliveryList
      ).map((delivery: DeliveryItem, index: number) => ({
        id: index + 1,
        address: delivery.endereco,
        hawb: delivery.hawb_completa,
        isRemoved: delivery.isRemoved,
      })),
    ] as DeliveriesInfo;

    /* Formatting the routed list */
    const formatedRoutedDeliveryList = formatRoutedDeliveryList(
      routedDeliveryList,
      deliveriesInfo
    );

    /* Getting only the steps from the routed list. Each step
        represents a delivery */
    const finalRoutedDeliveryList = formatedRoutedDeliveryList.map((route) => {
      return route.steps.map((step, index) => {
        return {
          hawb_completa: step.hawb,
          num_enc_cli: deliveryList[index].num_enc_cli as string,
          lat: String(step.location[1]),
          lng: String(step.location[0]),
          endereco: step.address,
          isRemoved: step.isRemoved,
        };
      });
    })[0];

    if (notRemovedDeliveryList.length > 0) {
      removedDeliveryList.forEach((delivery) =>
        finalRoutedDeliveryList.push(delivery)
      );
    }

    return {
      routeDetails: formatedRoutedDeliveryList,
      routedDeliveryList: finalRoutedDeliveryList,
    };
  } catch {
    return null;
  }
};

export default getRoutedDeliveryList;
